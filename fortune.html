<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortune's Hand</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #1a5c2e;
            background-image: radial-gradient(circle at center, #2a7c4e 0%, #1a5c2e 100%);
            color: white;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-size: 2.5rem;
            color: #f0c14b;
            letter-spacing: 2px;
        }
        
        .game-info {
            text-align: center;
            margin-bottom: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-around;
        }
        
        .score {
            font-size: 24px;
            font-weight: bold;
            color: #f0c14b;
        }
        
        .cards-remaining {
            font-size: 18px;
        }
        
        .hand-container {
            position: relative;
            height: 240px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
        }
        
        .hand {
            display: flex;
            justify-content: center;
            gap: 15px;
            position: relative;
            height: 100%;
            flex-grow: 1;
            margin-left: 160px; /* Space for the deck */
        }
        
        .card {
            width: 120px;
            height: 180px;
            background-color: white;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            color: black;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                        box-shadow 0.3s ease,
                        opacity 0.3s ease;
            position: absolute;
            transform-origin: center bottom;
            opacity: 1;
        }
        
        .card-position {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }
        
        .card.selected {
            transform: translateY(-30px);
            box-shadow: 0 0 20px gold;
        }
        
        .card.removing {
            transform: translateY(-100px) scale(0.8);
            opacity: 0;
        }
        
        .card.dealing {
            animation: dealCard 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        
        @keyframes dealCard {
            0% {
                transform: translateY(50px) scale(0.8);
                opacity: 0;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        .card-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .card-bottom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            transform: rotate(180deg);
        }
        
        .card-value {
            font-size: 24px;
            font-weight: bold;
        }
        
        .card-suit {
            font-size: 24px;
            line-height: 1;
        }
        
        .hearts, .diamonds {
            color: #e62e2e;
        }
        
        .spades, .clubs {
            color: #202020;
        }
        
        .card-center {
            font-size: 48px;
            text-align: center;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        button {
            background-color: #f0c14b;
            color: #111;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        button:hover {
            background-color: #ddb347;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .message {
            text-align: center;
            font-size: 20px;
            margin-bottom: 20px;
            min-height: 30px;
            padding: 10px;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .message.highlight {
            background-color: rgba(240, 193, 75, 0.2);
            animation: pulse 1s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { background-color: rgba(240, 193, 75, 0.2); }
            50% { background-color: rgba(240, 193, 75, 0.4); }
        }
        
        .rules {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            overflow: hidden;
        }
        
        .rules-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        .rules-header h2 {
            margin: 0;
            color: #f0c14b;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .rules-toggle {
            font-size: 24px;
            color: #f0c14b;
            transition: transform 0.3s ease;
        }
        
        .rules-content {
            max-height: 0;
            opacity: 0;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, margin 0.3s ease-in-out;
            margin-top: 0;
        }
        
        .rules.expanded .rules-content {
            max-height: 500px;
            opacity: 1;
            margin-top: 15px;
        }
        
        .rules.expanded .rules-toggle {
            transform: rotate(180deg);
        }
        
        .rules h2 {
            margin-top: 0;
            color: #f0c14b;
            border-bottom: 1px solid rgba(240, 193, 75, 0.3);
            padding-bottom: 10px;
        }
        
        .rules ul {
            padding-left: 20px;
            line-height: 1.6;
        }
        
        .rules li {
            margin-bottom: 8px;
        }
        
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .game-over-content {
            background-color: #1a5c2e;
            background-image: radial-gradient(circle at center, #2a7c4e 0%, #1a5c2e 100%);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: scaleIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes scaleIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #f0c14b;
        }
        
        .final-score {
            font-size: 60px;
            margin-bottom: 15px;
            color: #f0c14b;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .game-stats {
            font-size: 14px;
            margin-bottom: 25px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .bonus {
            color: #f0c14b;
            font-weight: bold;
        }
        
        .deck-area {
            position: absolute;
            left: 0;
            top: 0;
            width: 140px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }
        
        .deck-label {
            font-size: 14px;
            margin-bottom: 5px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }
        
        .card-back {
            width: 120px;
            height: 180px;
            background-color: #2a3f5f;
            border-radius: 10px;
            background-image: repeating-linear-gradient(
                45deg,
                #2a3f5f,
                #2a3f5f 10px,
                #253550 10px,
                #253550 20px
            );
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .card-back:before {
            content: "♠♥♣♦";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: rgba(255, 255, 255, 0.2);
        }
        
        .next-card {
            width: 120px;
            height: 180px;
            background-color: white;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            color: black;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            transform: rotate(5deg);
        }
        
        .next-card .card-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex: 0 0 auto;
            height: auto;
            width: 100%;
        }
        
        .next-card .card-center {
            font-size: 48px;
            flex: 1 1 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 80px;
            width: 100%;
        }
        
        .next-card .card-bottom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            transform: rotate(180deg);
            flex: 0 0 auto;
            height: auto;
            width: 100%;
        }
        
        .next-card .card-value {
            font-size: 24px;
            font-weight: bold;
        }
        
        .next-card .card-suit {
            font-size: 24px;
            line-height: 1;
        }
        
        .next-card.hearts, .next-card.diamonds {
            color: #e62e2e;
        }
        
        .next-card.spades, .next-card.clubs {
            color: #202020;
        }
        
        .next-card-hidden {
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 16px;
            width: 120px;
            height: 180px;
            box-sizing: border-box;
            padding: 10px;
            transform: rotate(5deg);
        }
        
        .key-hint {
            opacity: 0.5;
            font-size: 0.9em;
            margin-left: 5px;
        }
        
        .confirm-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .confirm-popup.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .confirm-content {
            background-color: #1a5c2e;
            background-image: radial-gradient(circle at center, #2a7c4e 0%, #1a5c2e 100%);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .confirm-popup.active .confirm-content {
            transform: scale(1);
        }
        
        .confirm-popup h3 {
            color: #f0c14b;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .confirm-popup p {
            margin-bottom: 25px;
            font-size: 16px;
            line-height: 1.5;
        }
        
        .confirm-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .confirm-buttons button {
            min-width: 100px;
        }
        
        .confirm-buttons .cancel-btn {
            background-color: #666;
        }
        
        .confirm-buttons .cancel-btn:hover {
            background-color: #777;
        }
    </style>
</head>
<body>
    <h1>Fortune's Hand</h1>
    
    <div class="game-info">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="cards-remaining">Cards Remaining: <span id="cards-remaining">47</span></div>
    </div>
    
    <div class="message" id="message"></div>
    
    <div class="hand-container">
        <div class="deck-area" id="deck-area">
            <div class="deck-label"> </div>
            <div class="card-back" id="card-back"></div>
            <div class="deck-label"></div>
            <div id="next-card" class="next-card next-card-hidden">No more cards</div>
        </div>
        <div class="hand" id="hand"></div>
    </div>
    
    <div class="controls">
        <button id="play-set">Play Selected Cards <span class="key-hint">↵</span></button>
        <button id="new-game">New Game <span class="key-hint">⇧N</span></button>
    </div>
    
    <div class="rules">
        <div class="rules-header" id="rules-header">
            <h2>Game Rules</h2>
            <div class="rules-toggle">▼</div>
        </div>
        <div class="rules-content">
            <p>Select cards to form valid sets and discard them for points. You'll draw new cards automatically.</p>
            <ul>
                <li>Single Face Card (J, Q, K, A) scores 1, 2, 3, 4 points respectively</li>
                <li>A Pair (two same value) scores 5 points</li>
                <li>Run (3 cards in order) scores 15 points</li>
                <li>Run (4 cards in order) scores 25 points</li>
                <li>Three of a Kind scores 30 points</li>
                <li>Straight (5 cards in order) scores 40 points</li>
                <li>Flush (5 cards same suit) scores 50 points</li>
                <li>Four of a Kind scores 80 points</li>
            </ul>
            <p>Game ends when you run out of cards in the deck or have a hand with no valid sets.</p>
        </div>
    </div>
    
    <div class="game-over" id="game-over">
        <div class="game-over-content">
            <h2>Game Over!</h2>
            <div>Final Score: <span class="final-score" id="final-score">0</span></div>
            <div class="game-stats" id="game-stats"></div>
            <button id="play-again">Play Again</button>
        </div>
    </div>
    
    <div class="confirm-popup" id="confirm-popup">
        <div class="confirm-content">
            <h3>Confirm New Game</h3>
            <p>Are you sure you want to start a new game?</p>
            <div class="confirm-buttons">
                <button class="cancel-btn">Cancel</button>
                <button id="confirm-new-game">Confirm</button>
            </div>
        </div>
    </div>
    
    <script>
        const VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
        const SUIT_SYMBOLS = {
            'hearts': '♥',
            'diamonds': '♦',
            'clubs': '♣',
            'spades': '♠'
        };
        
        // Game state
        let deck = [];
        let hand = [];
        let score = 0;
        let selectedCards = [];
        let animationInProgress = false;
        let emptyDeckBonus = false;
        let gameStats = {
            cardsLeft: 0,
            emptyDeckBonus: false,
            remainingCardPoints: 0
        };
        
        // DOM elements
        const handElement = document.getElementById('hand');
        const scoreElement = document.getElementById('score');
        const cardsRemainingElement = document.getElementById('cards-remaining');
        const messageElement = document.getElementById('message');
        const playSetButton = document.getElementById('play-set');
        const newGameButton = document.getElementById('new-game');
        const gameOverElement = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const playAgainButton = document.getElementById('play-again');
        const deckAreaElement = document.getElementById('deck-area');
        const cardBackElement = document.getElementById('card-back');
        const confirmPopup = document.getElementById('confirm-popup');
        
        // Initialize the game
        function initGame() {
            // Create and shuffle the deck
            deck = [];
            // Create a standard 52-card deck with no duplicates
            for (const suit of SUITS) {
                for (const value of VALUES) {
                    deck.push({ value, suit });
                }
            }
            shuffleDeck();
            
            // Verify deck has 52 unique cards (for debugging)
            console.log(`Deck created with ${deck.length} cards`);
            const uniqueCards = new Set(deck.map(card => `${card.value}-${card.suit}`));
            console.log(`Unique cards: ${uniqueCards.size}`);
            
            // Reset game state
            hand = [];
            score = 0;
            selectedCards = [];
            emptyDeckBonus = false;
            gameStats = {
                cardsLeft: 0,
                emptyDeckBonus: false,
                remainingCardPoints: 0
            };
            
            // Deal initial hand
            dealHand();
            
            // Update UI
            updateUI();
            
            // Hide game over screen
            gameOverElement.style.display = 'none';
            
            // Update deck display
            updateDeckDisplay();
        }
        
        // Update deck display
        function updateDeckDisplay() {
            if (deck.length === 0) {
                cardBackElement.style.display = 'none';
            } else {
                cardBackElement.style.display = 'block';
            }
            
            // Update next card preview
            updateNextCardPreview();
        }
        
        // Update next card preview
        function updateNextCardPreview() {
            const nextCardElement = document.getElementById('next-card');
            
            if (deck.length > 0) {
                // The next card to be drawn is the LAST card in the deck array
                // because we're using pop() to draw cards
                const nextCard = deck[deck.length - 1];
                nextCardElement.className = `next-card ${nextCard.suit}`;
                
                // Create card content with proper suit coloring
                const suitSymbol = SUIT_SYMBOLS[nextCard.suit];
                const isRedSuit = nextCard.suit === 'hearts' || nextCard.suit === 'diamonds';
                const suitColor = isRedSuit ? '#e62e2e' : '#202020';
                
                nextCardElement.innerHTML = `
                    <div class="card-top">
                        <div class="card-value">${nextCard.value}</div>
                        <div class="card-suit" style="color: ${suitColor}">${suitSymbol}</div>
                    </div>
                    <div class="card-center" style="color: ${suitColor}">${suitSymbol}</div>
                    <div class="card-bottom">
                        <div class="card-value">${nextCard.value}</div>
                        <div class="card-suit" style="color: ${suitColor}">${suitSymbol}</div>
                    </div>
                `;
            } else {
                nextCardElement.className = 'next-card next-card-hidden';
                nextCardElement.innerHTML = 'No more cards';
            }
        }
        
        // Shuffle the deck using Fisher-Yates algorithm
        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }
        
        // Deal cards to fill the hand
        function dealHand() {
            const newCards = [];
            while (hand.length < 5 && deck.length > 0) {
                // Pop the last card from the deck (the one shown in the preview)
                const newCard = deck.pop();
                hand.push(newCard);
                newCards.push(newCard);
            }
            return newCards;
        }
        
        // Render the hand
        function renderHand(newCards = []) {
            handElement.innerHTML = '';
            
            // Calculate card positions
            const cardWidth = 120;
            const cardGap = 15;
            const totalWidth = hand.length * cardWidth + (hand.length - 1) * cardGap;
            const startX = (handElement.offsetWidth - totalWidth) / 2;
            
            hand.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = `card ${card.suit}`;
                if (selectedCards.includes(index)) {
                    cardElement.classList.add('selected');
                }
                
                // Check if this is a new card
                const isNewCard = newCards.includes(card);
                if (isNewCard) {
                    cardElement.classList.add('dealing');
                }
                
                const displayValue = card.value;
                
                cardElement.innerHTML = `
                    <div class="card-top">
                        <div class="card-value">${displayValue}</div>
                        <div class="card-suit">${SUIT_SYMBOLS[card.suit]}</div>
                    </div>
                    <div class="card-center">${SUIT_SYMBOLS[card.suit]}</div>
                    <div class="card-bottom">
                        <div class="card-value">${displayValue}</div>
                        <div class="card-suit">${SUIT_SYMBOLS[card.suit]}</div>
                    </div>
                `;
                
                // Position the card
                const xPos = startX + index * (cardWidth + cardGap);
                cardElement.style.left = `${xPos}px`;
                
                // Add position indicator
                const positionIndicator = document.createElement('div');
                positionIndicator.className = 'card-position';
                positionIndicator.textContent = (index + 1).toString();
                cardElement.appendChild(positionIndicator);
                
                cardElement.addEventListener('click', () => toggleCardSelection(index));
                handElement.appendChild(cardElement);
            });
            
            // Update next card preview
            updateNextCardPreview();
        }
        
        // Toggle card selection
        function toggleCardSelection(index) {
            if (animationInProgress) return;
            
            const cardIndex = selectedCards.indexOf(index);
            if (cardIndex === -1) {
                selectedCards.push(index);
            } else {
                selectedCards.splice(cardIndex, 1);
            }
            
            // Sort selected cards by index
            selectedCards.sort((a, b) => a - b);
            
            renderHand();
            validateSelection();
        }
        
        // Get the numeric value of a card for scoring
        function getCardValue(card, aceAsLow = false) {
            if (card.value === 'A') return aceAsLow ? 1 : 14;
            if (card.value === 'K') return 13;
            if (card.value === 'Q') return 12;
            if (card.value === 'J') return 11;
            return parseInt(card.value);
        }
        
        // Get the face value of a card for display
        function getFaceValue(card) {
            if (card.value === 'J') return 1;
            if (card.value === 'Q') return 2;
            if (card.value === 'K') return 3;
            if (card.value === 'A') return 4;
            return parseInt(card.value);
        }
        
        // Validate the current selection
        function validateSelection() {
            if (selectedCards.length === 0) {
                messageElement.textContent = '';
                messageElement.classList.remove('highlight');
                playSetButton.disabled = true;
                return;
            }
            
            const selectedCardObjects = selectedCards.map(index => hand[index]);
            
            // Check for valid sets
            const validationResult = validateSet(selectedCardObjects);
            
            if (validationResult.valid) {
                messageElement.textContent = `Valid ${validationResult.type} (${validationResult.points} points)`;
                messageElement.classList.add('highlight');
                playSetButton.disabled = false;
            } else {
                messageElement.textContent = 'Not a valid set';
                messageElement.classList.remove('highlight');
                playSetButton.disabled = true;
            }
        }
        
        // Validate if selected cards form a valid set
        function validateSet(cards) {
            // Sort cards by value for easier validation
            const sortedCards = [...cards].sort((a, b) => getCardValue(a) - getCardValue(b));
            
            // Check for a single face card (J, Q, K, A)
            if (cards.length === 1) {
                const card = cards[0];
                if (card.value === 'J') {
                    return { valid: true, type: 'Jack', points: 1 };
                } else if (card.value === 'Q') {
                    return { valid: true, type: 'Queen', points: 2 };
                } else if (card.value === 'K') {
                    return { valid: true, type: 'King', points: 3 };
                } else if (card.value === 'A') {
                    return { valid: true, type: 'Ace', points: 4 };
                }
            }
            
            // Check for a pair (2 cards of the same value)
            if (cards.length === 2 && cards[0].value === cards[1].value) {
                return { valid: true, type: 'Pair', points: 5 };
            }
            
            // Check for three of a kind
            if (cards.length === 3 && cards[0].value === cards[1].value && cards[1].value === cards[2].value) {
                return { valid: true, type: 'Three of a Kind', points: 30 };
            }
            
            // Check for four of a kind
            if (cards.length === 4 && cards[0].value === cards[1].value && cards[1].value === cards[2].value && cards[2].value === cards[3].value) {
                return { valid: true, type: 'Four of a Kind', points: 80 };
            }
            
            // Check for a run of 3
            if (cards.length === 3) {
                const values = sortedCards.map(card => getCardValue(card));
                if (values[1] === values[0] + 1 && values[2] === values[1] + 1) {
                    return { valid: true, type: 'Run of 3', points: 15 };
                }
                
                // Check if there's an Ace that can be used as 1
                if (sortedCards.some(card => card.value === 'A')) {
                    const lowAceValues = sortedCards.map(card => getCardValue(card, card.value === 'A'));
                    lowAceValues.sort((a, b) => a - b);
                    if (lowAceValues[1] === lowAceValues[0] + 1 && lowAceValues[2] === lowAceValues[1] + 1) {
                        return { valid: true, type: 'Run of 3 (A low)', points: 15 };
                    }
                }
            }
            
            // Check for a run of 4
            if (cards.length === 4) {
                const values = sortedCards.map(card => getCardValue(card));
                if (values[1] === values[0] + 1 && values[2] === values[1] + 1 && values[3] === values[2] + 1) {
                    return { valid: true, type: 'Run of 4', points: 25 };
                }
                
                // Check if there's an Ace that can be used as 1
                if (sortedCards.some(card => card.value === 'A')) {
                    const lowAceValues = sortedCards.map(card => getCardValue(card, card.value === 'A'));
                    lowAceValues.sort((a, b) => a - b);
                    if (lowAceValues[1] === lowAceValues[0] + 1 && 
                        lowAceValues[2] === lowAceValues[1] + 1 && 
                        lowAceValues[3] === lowAceValues[2] + 1) {
                        return { valid: true, type: 'Run of 4 (A low)', points: 25 };
                    }
                }
            }
            
            // Check for a Straight (5 cards in sequential order)
            if (cards.length === 5) {
                const values = sortedCards.map(card => getCardValue(card));
                if (values[1] === values[0] + 1 && 
                    values[2] === values[1] + 1 && 
                    values[3] === values[2] + 1 && 
                    values[4] === values[3] + 1) {
                    return { valid: true, type: 'Straight', points: 80 };
                }
                
                // Check if there's an Ace that can be used as 1
                if (sortedCards.some(card => card.value === 'A')) {
                    const lowAceValues = sortedCards.map(card => getCardValue(card, card.value === 'A'));
                    lowAceValues.sort((a, b) => a - b);
                    if (lowAceValues[1] === lowAceValues[0] + 1 && 
                        lowAceValues[2] === lowAceValues[1] + 1 && 
                        lowAceValues[3] === lowAceValues[2] + 1 && 
                        lowAceValues[4] === lowAceValues[3] + 1) {
                        return { valid: true, type: 'Straight (A low)', points: 80 };
                    }
                }
                
                // Check for a flush (5 cards of the same suit)
                const suit = cards[0].suit;
                if (cards.every(card => card.suit === suit)) {
                    return { valid: true, type: 'Flush', points: 50 };
                }
            }
            
            return { valid: false };
        }
        
        // Play the selected set with animation
        function playSet() {
            if (animationInProgress) return;
            
            const selectedCardObjects = selectedCards.map(index => hand[index]);
            const validationResult = validateSet(selectedCardObjects);
            
            if (validationResult.valid) {
                animationInProgress = true;
                
                // Add points to score
                score += validationResult.points;
                scoreElement.textContent = score;
                
                // Animate card removal
                const cardElements = document.querySelectorAll('.card');
                selectedCards.forEach(index => {
                    cardElements[index].classList.add('removing');
                });
                
                // Wait for removal animation to complete
                setTimeout(() => {
                    // Remove selected cards from hand (in reverse order to maintain indices)
                    selectedCards.sort((a, b) => b - a).forEach(index => {
                        hand.splice(index, 1);
                    });
                    
                    // Deal new cards
                    const newCards = dealHand();
                    
                    // Reset selection
                    selectedCards = [];
                    
                    // Update UI
                    renderHand(newCards);
                    cardsRemainingElement.textContent = deck.length;
                    messageElement.textContent = '';
                    messageElement.classList.remove('highlight');
                    playSetButton.disabled = true;
                    
                    // Update deck display
                    updateDeckDisplay();
                    
                    // Check if game is over
                    setTimeout(() => {
                        animationInProgress = false;
                        checkGameOver();
                    }, 500); // Wait for deal animation
                    
                }, 500); // Wait for removal animation
            }
        }
        
        
        function checkGameOver() {
            
            if (deck.length === 0 && !emptyDeckBonus) {
                score += 25;
                scoreElement.textContent = score;
                emptyDeckBonus = true;
                messageElement.textContent = "Deck emptied! +25 point bonus!";
                messageElement.classList.add('highlight');
            }
            
            
            if (!hasValidSet()) {
                
                if (deck.length === 0 && hand.length > 0) {
                    const remainingCardPoints = hand.length;
                    score += remainingCardPoints;
                    scoreElement.textContent = score;
                }
                
                
                gameStats.cardsLeft = deck.length;
                gameStats.emptyDeckBonus = emptyDeckBonus;
                
                
                messageElement.textContent = "No valid sets possible. Game over!";
                messageElement.classList.add('highlight');
                setTimeout(() => {
                    endGame();
                }, 1500);
                return true;
            }
            
            return false;
        }
        
        
        function hasValidSet() {
            // Cface cards
            for (let i = 0; i < hand.length; i++) {
                const card = hand[i];
                if (card.value === 'J' || card.value === 'Q' || card.value === 'K' || card.value === 'A') {
                    return true;
                }
            }
            
            
            // Pairs
            for (let i = 0; i < hand.length; i++) {
                for (let j = i + 1; j < hand.length; j++) {
                    if (hand[i].value === hand[j].value) {
                        return true;
                    }
                }
            }
            
            // Three of a kind
            for (let i = 0; i < hand.length; i++) {
                for (let j = i + 1; j < hand.length; j++) {
                    for (let k = j + 1; k < hand.length; k++) {
                        if (hand[i].value === hand[j].value && hand[j].value === hand[k].value) {
                            return true;
                        }
                    }
                }
            }
            
            // Four of a kind
            for (let i = 0; i < hand.length; i++) {
                for (let j = i + 1; j < hand.length; j++) {
                    for (let k = j + 1; k < hand.length; k++) {
                        for (let l = k + 1; l < hand.length; l++) {
                            if (hand[i].value === hand[j].value && hand[j].value === hand[k].value && hand[k].value === hand[l].value) {
                                return true;
                            }
                        }
                    }
                }
            }
            
            // Runs of 3
            const handCopy = [...hand];
            handCopy.sort((a, b) => getCardValue(a) - getCardValue(b));
            for (let i = 0; i < handCopy.length - 2; i++) {
                const val1 = getCardValue(handCopy[i]);
                const val2 = getCardValue(handCopy[i + 1]);
                const val3 = getCardValue(handCopy[i + 2]);
                if (val2 === val1 + 1 && val3 === val2 + 1) {
                    return true;
                }
            }
            
            // Check for runs of 3 with Ace as low
            if (handCopy.some(card => card.value === 'A')) {
                const lowAceHandCopy = [...hand];
                lowAceHandCopy.sort((a, b) => getCardValue(a, a.value === 'A') - getCardValue(b, b.value === 'A'));
                
                for (let i = 0; i < lowAceHandCopy.length - 2; i++) {
                    const val1 = getCardValue(lowAceHandCopy[i], lowAceHandCopy[i].value === 'A');
                    const val2 = getCardValue(lowAceHandCopy[i + 1], lowAceHandCopy[i + 1].value === 'A');
                    const val3 = getCardValue(lowAceHandCopy[i + 2], lowAceHandCopy[i + 2].value === 'A');
                    if (val2 === val1 + 1 && val3 === val2 + 1) {
                        return true;
                    }
                }
            }
            
            // Runs of 4
            for (let i = 0; i < handCopy.length - 3; i++) {
                const val1 = getCardValue(handCopy[i]);
                const val2 = getCardValue(handCopy[i + 1]);
                const val3 = getCardValue(handCopy[i + 2]);
                const val4 = getCardValue(handCopy[i + 3]);
                if (val2 === val1 + 1 && val3 === val2 + 1 && val4 === val3 + 1) {
                    return true;
                }
            }
            
            // Check for runs of 4 with Ace as low
            if (handCopy.some(card => card.value === 'A')) {
                const lowAceHandCopy = [...hand];
                lowAceHandCopy.sort((a, b) => getCardValue(a, a.value === 'A') - getCardValue(b, b.value === 'A'));
                
                for (let i = 0; i < lowAceHandCopy.length - 3; i++) {
                    const val1 = getCardValue(lowAceHandCopy[i], lowAceHandCopy[i].value === 'A');
                    const val2 = getCardValue(lowAceHandCopy[i + 1], lowAceHandCopy[i + 1].value === 'A');
                    const val3 = getCardValue(lowAceHandCopy[i + 2], lowAceHandCopy[i + 2].value === 'A');
                    const val4 = getCardValue(lowAceHandCopy[i + 3], lowAceHandCopy[i + 3].value === 'A');
                    if (val2 === val1 + 1 && val3 === val2 + 1 && val4 === val3 + 1) {
                        return true;
                    }
                }
            }
            
            // Runs of 5
            if (handCopy.length === 5) {
                const val1 = getCardValue(handCopy[0]);
                const val2 = getCardValue(handCopy[1]);
                const val3 = getCardValue(handCopy[2]);
                const val4 = getCardValue(handCopy[3]);
                const val5 = getCardValue(handCopy[4]);
                if (val2 === val1 + 1 && val3 === val2 + 1 && val4 === val3 + 1 && val5 === val4 + 1) {
                    return true;
                }
                
                // Check for straight with Ace as low
                if (handCopy.some(card => card.value === 'A')) {
                    const lowAceHandCopy = [...hand];
                    lowAceHandCopy.sort((a, b) => getCardValue(a, a.value === 'A') - getCardValue(b, b.value === 'A'));
                    
                    const val1 = getCardValue(lowAceHandCopy[0], lowAceHandCopy[0].value === 'A');
                    const val2 = getCardValue(lowAceHandCopy[1], lowAceHandCopy[1].value === 'A');
                    const val3 = getCardValue(lowAceHandCopy[2], lowAceHandCopy[2].value === 'A');
                    const val4 = getCardValue(lowAceHandCopy[3], lowAceHandCopy[3].value === 'A');
                    const val5 = getCardValue(lowAceHandCopy[4], lowAceHandCopy[4].value === 'A');
                    
                    if (val2 === val1 + 1 && val3 === val2 + 1 && val4 === val3 + 1 && val5 === val4 + 1) {
                        return true;
                    }
                }
            }
            
            // Flush
            if (hand.length === 5) {
                const suit = hand[0].suit;
                if (hand.every(card => card.suit === suit)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // end the game
        function endGame() {
            finalScoreElement.textContent = score;
            
            
            const statsElement = document.getElementById('game-stats');
            let statsHTML = `<div>Cards left in deck: ${gameStats.cardsLeft}</div>`;
            
            if (gameStats.emptyDeckBonus) {
                statsHTML += `<div class="bonus">Empty deck! +25 points</div>`;
            }
            
            statsElement.innerHTML = statsHTML;
            
            
            gameOverElement.style.display = 'flex';
        }
        
        
        function updateUI() {
            renderHand();
            scoreElement.textContent = score;
            cardsRemainingElement.textContent = deck.length;
            messageElement.textContent = '';
            messageElement.classList.remove('highlight');
            playSetButton.disabled = true;
        }
        
            
        playSetButton.addEventListener('click', playSet);
        newGameButton.addEventListener('click', () => {
            confirmPopup.classList.add('active');
        });
        playAgainButton.addEventListener('click', initGame);
        
            
        document.getElementById('rules-header').addEventListener('click', () => {
            document.querySelector('.rules').classList.toggle('expanded');
        });
        
        // Single keydown event listener to handle all keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            // Handle Escape key for closing the confirmation popup
            if (event.key === 'Escape' && confirmPopup.classList.contains('active')) {
                confirmPopup.classList.remove('active');
                return;
            }
            
            // Prevent default browser behavior for our keyboard shortcuts
            if (['1', '2', '3', '4', '5', 'Enter', 'N'].includes(event.key)) {
                event.preventDefault();
            }
            
            // Don't process other keyboard events during animations
            if (animationInProgress) return;
            
            // Don't process card selection keys when confirmation popup is open
            if (confirmPopup.classList.contains('active')) return;
            
            // Number keys 1-5 select/deselect cards
            if (event.key >= '1' && event.key <= '5') {
                const cardIndex = parseInt(event.key) - 1;
                
                if (cardIndex >= 0 && cardIndex < hand.length) {
                    const selectedIndex = selectedCards.indexOf(cardIndex);
                    if (selectedIndex === -1) {
                        selectedCards.push(cardIndex);
                    } else {
                        selectedCards.splice(selectedIndex, 1);
                    }
                    
                    selectedCards.sort((a, b) => a - b);
                    
                    renderHand();
                    validateSelection();
                }
            }
            
            // Enter key plays the selected set if valid
            if (event.key === 'Enter' && !playSetButton.disabled) {
                playSet();
            }
            
            // Shift+N shows the new game confirmation popup
            if ((event.key === 'N' || event.key === 'n') && event.shiftKey) {
                event.preventDefault();
                confirmPopup.classList.add('active');
            }
        });
        
        // Confirm new game button
        document.getElementById('confirm-new-game').addEventListener('click', () => {
            confirmPopup.classList.remove('active');
            initGame();
        });
        
        // Cancel button in confirmation popup
        document.querySelector('.cancel-btn').addEventListener('click', () => {
            confirmPopup.classList.remove('active');
        });
        
        // Close popup when clicking outside the content
        confirmPopup.addEventListener('click', (e) => {
            if (e.target === confirmPopup) {
                confirmPopup.classList.remove('active');
            }
        });
        
        window.addEventListener('resize', () => {
            renderHand();
        });
        
        initGame();
    </script>
</body>
</html>
